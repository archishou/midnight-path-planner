{"ast":null,"code":"import WrapperMatrix2D from '../wrap/WrapperMatrix2D';\nimport Matrix from '../matrix';\nexport default class nipals {\n  constructor(X, options = {}) {\n    X = WrapperMatrix2D.checkMatrix(X);\n    let Y = options.Y;\n    const _options$scaleScores = options.scaleScores,\n          scaleScores = _options$scaleScores === void 0 ? false : _options$scaleScores,\n          _options$maxIteration = options.maxIterations,\n          maxIterations = _options$maxIteration === void 0 ? 1000 : _options$maxIteration,\n          _options$terminationC = options.terminationCriteria,\n          terminationCriteria = _options$terminationC === void 0 ? 1e-10 : _options$terminationC;\n    let u;\n\n    if (Y) {\n      if (Array.isArray(Y) && typeof Y[0] === 'number') {\n        Y = Matrix.columnVector(Y);\n      } else {\n        Y = WrapperMatrix2D.checkMatrix(Y);\n      }\n\n      if (!Y.isColumnVector() || Y.rows !== X.rows) {\n        throw new Error('Y must be a column vector of length X.rows');\n      }\n\n      u = Y;\n    } else {\n      u = X.getColumnVector(0);\n    }\n\n    let diff = 1;\n    let t, q, w, tOld;\n\n    for (let counter = 0; counter < maxIterations && diff > terminationCriteria; counter++) {\n      w = X.transpose().mmul(u).div(u.transpose().mmul(u).get(0, 0));\n      w = w.div(w.norm());\n      t = X.mmul(w).div(w.transpose().mmul(w).get(0, 0));\n\n      if (counter > 0) {\n        diff = t.clone().sub(tOld).pow(2).sum();\n      }\n\n      tOld = t.clone();\n\n      if (Y) {\n        q = Y.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));\n        q = q.div(q.norm());\n        u = Y.mmul(q).div(q.transpose().mmul(q).get(0, 0));\n      } else {\n        u = t;\n      }\n    }\n\n    if (Y) {\n      let p = X.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));\n      p = p.div(p.norm());\n      let xResidual = X.clone().sub(t.clone().mmul(p.transpose()));\n      let residual = u.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));\n      let yResidual = Y.clone().sub(t.clone().mulS(residual.get(0, 0)).mmul(q.transpose()));\n      this.t = t;\n      this.p = p.transpose();\n      this.w = w.transpose();\n      this.q = q;\n      this.u = u;\n      this.s = t.transpose().mmul(t);\n      this.xResidual = xResidual;\n      this.yResidual = yResidual;\n      this.betas = residual;\n    } else {\n      this.w = w.transpose();\n      this.s = t.transpose().mmul(t).sqrt();\n\n      if (scaleScores) {\n        this.t = t.clone().div(this.s.get(0, 0));\n      } else {\n        this.t = t;\n      }\n\n      this.xResidual = X.sub(t.mmul(w.transpose()));\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}