{"ast":null,"code":"import Matrix from './matrix';\nimport SingularValueDecomposition from './dc/svd';\n\nfunction xrange(n, exception) {\n  let range = [];\n\n  for (let i = 0; i < n; i++) {\n    if (i !== exception) {\n      range.push(i);\n    }\n  }\n\n  return range;\n}\n\nfunction dependenciesOneRow(error, matrix, index, thresholdValue = 10e-10, thresholdError = 10e-10) {\n  if (error > thresholdError) {\n    return new Array(matrix.rows + 1).fill(0);\n  } else {\n    let returnArray = matrix.addRow(index, [0]);\n\n    for (let i = 0; i < returnArray.rows; i++) {\n      if (Math.abs(returnArray.get(i, 0)) < thresholdValue) {\n        returnArray.set(i, 0, 0);\n      }\n    }\n\n    return returnArray.to1DArray();\n  }\n}\n\nexport function linearDependencies(matrix, options = {}) {\n  const _options$thresholdVal = options.thresholdValue,\n        thresholdValue = _options$thresholdVal === void 0 ? 10e-10 : _options$thresholdVal,\n        _options$thresholdErr = options.thresholdError,\n        thresholdError = _options$thresholdErr === void 0 ? 10e-10 : _options$thresholdErr;\n  matrix = Matrix.checkMatrix(matrix);\n  let n = matrix.rows;\n  let results = new Matrix(n, n);\n\n  for (let i = 0; i < n; i++) {\n    let b = Matrix.columnVector(matrix.getRow(i));\n    let Abis = matrix.subMatrixRow(xrange(n, i)).transpose();\n    let svd = new SingularValueDecomposition(Abis);\n    let x = svd.solve(b);\n    let error = Matrix.sub(b, Abis.mmul(x)).abs().max();\n    results.setRow(i, dependenciesOneRow(error, x, i, thresholdValue, thresholdError));\n  }\n\n  return results;\n}","map":null,"metadata":{},"sourceType":"module"}