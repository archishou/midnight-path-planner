{"ast":null,"code":"import { Matrix, solve } from \"ml-matrix\";\nimport Point from './Point';\nimport Segment from './Segment';\nimport Constants from \"../Components/Constants\";\n\nfunction generateConstraintMatrix(ns) {\n  // Each point apart from the initial point, requires 4 constraints. N represents the number of constraints.\n  let numPoints = ns.length;\n  let n = (numPoints - 1) * 4;\n  let matrix = new Array(n).fill(0).map(row => new Array(n).fill(0));\n  if (numPoints === 1) return null; // Initial velocity = 0\n\n  matrix[0][1] = 1; // Final velocity = 0\n\n  matrix[1][n - 1] = 3;\n  matrix[1][n - 2] = 2;\n  matrix[1][n - 3] = 1; // We filled equations 0 & 1 with initial and final velocity constraint.\n\n  let equationIndex = 2;\n  let pointIndex = 1;\n\n  while (equationIndex < n) {\n    // Start of segment is equal to initial point.\n    let segmentIndexStart = (pointIndex - 1) * 4;\n    matrix[equationIndex][segmentIndexStart] = 1;\n    equationIndex++; // End of segment is equal to destination.\n\n    let segmentCoeffIndex = 0;\n\n    while (segmentCoeffIndex < 4) {\n      matrix[equationIndex][segmentCoeffIndex + segmentIndexStart] = 1;\n      segmentCoeffIndex++;\n    }\n\n    equationIndex++; // Smooth velocities and accelerations if there is another point left to complete\n\n    if (pointIndex < numPoints - 1) {\n      // Velocity Constraint\n      matrix[equationIndex][segmentIndexStart + 1] = 1;\n      matrix[equationIndex][segmentIndexStart + 2] = 2;\n      matrix[equationIndex][segmentIndexStart + 3] = 3;\n      matrix[equationIndex][segmentIndexStart + 5] = -1;\n      equationIndex++;\n      matrix[equationIndex][segmentIndexStart + 2] = 2;\n      matrix[equationIndex][segmentIndexStart + 3] = 6;\n      matrix[equationIndex][segmentIndexStart + 6] = -2;\n      equationIndex++;\n    }\n\n    pointIndex++;\n  }\n\n  return new Matrix(matrix);\n}\n\nfunction generateSolutionsMatrix(ns) {\n  let numPoints = ns.length;\n  let n = (numPoints - 1) * 4;\n  let matrix = new Array(n).fill(0).map(row => new Array(1).fill(0));\n  let pointIndex = 0,\n      solutionIndex = 0;\n\n  while (solutionIndex < n) {\n    matrix[solutionIndex + 2][0] = ns[pointIndex];\n    matrix[solutionIndex + 3][0] = ns[pointIndex + 1]; //console.log(ns[pointIndex + 1]);\n    //console.log(matrix[solutionIndex + 3][0]);\n\n    solutionIndex += 4;\n    pointIndex++;\n  }\n\n  return new Matrix(matrix);\n}\n\nfunction getSegments(ns) {\n  let segments = [];\n  let constraints = generateConstraintMatrix(ns);\n  let solutions = generateSolutionsMatrix(ns);\n  if (constraints == null) return null;\n  let coeffs = solve(constraints, solutions); //console.log(solutions)\n\n  let n = coeffs.rows;\n  let index = 0;\n\n  while (index < n) {\n    segments.push(new Segment(coeffs.get(index + 3, 0), coeffs.get(index + 2, 0), coeffs.get(index + 1, 0), coeffs.get(index, 0)));\n    index += 4;\n  }\n\n  return segments;\n}\n\nexport default function GetPoints(knots) {\n  let xs = [];\n  let ys = [];\n  knots.forEach(e => {\n    xs.push(e.x);\n    ys.push(e.y);\n  });\n  let xSegments = getSegments(xs);\n  let ySegments = getSegments(ys);\n  if (xSegments == null || ySegments == null) return null;\n  let points = [];\n  let t = 0;\n  let resolution = Constants.PATH_RESOLUTION; // segments = knots - 1\n\n  let n = knots.length - 1;\n  let index = 0;\n\n  while (index < n) {\n    while (t < 1) {\n      points.push(new Point(xSegments[index].compute(t), ySegments[index].compute(t)));\n      t += resolution;\n    }\n\n    t = 0;\n    index++;\n  }\n\n  return points;\n}","map":{"version":3,"sources":["/Users/Archish/Downloads/react-router-layout-guide-master/src/pages/PathPlanning/HermiteCurveGenerator/Generator.js"],"names":["Matrix","solve","Point","Segment","Constants","generateConstraintMatrix","ns","numPoints","length","n","matrix","Array","fill","map","row","equationIndex","pointIndex","segmentIndexStart","segmentCoeffIndex","generateSolutionsMatrix","solutionIndex","getSegments","segments","constraints","solutions","coeffs","rows","index","push","get","GetPoints","knots","xs","ys","forEach","e","x","y","xSegments","ySegments","points","t","resolution","PATH_RESOLUTION","compute"],"mappings":"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","sourcesContent":["import {Matrix, solve} from \"ml-matrix\";\nimport Point from './Point'\nimport Segment from './Segment'\nimport Constants from \"../Components/Constants\";\nfunction generateConstraintMatrix(ns) {\n    // Each point apart from the initial point, requires 4 constraints. N represents the number of constraints.\n    let numPoints = ns.length;\n    let n = (numPoints - 1) * 4;\n    let matrix = new Array(n).fill(0).map(row => new Array(n).fill(0));\n    if (numPoints === 1) return null;\n    // Initial velocity = 0\n    matrix[0][1] = 1;\n    // Final velocity = 0\n    matrix[1][n-1] = 3;\n    matrix[1][n-2] = 2;\n    matrix[1][n-3] = 1;\n\n    // We filled equations 0 & 1 with initial and final velocity constraint.\n    let equationIndex = 2;\n    let pointIndex = 1;\n    while (equationIndex < n) {\n        // Start of segment is equal to initial point.\n        let segmentIndexStart = ((pointIndex - 1) * 4);\n        matrix[equationIndex][segmentIndexStart] = 1;\n        equationIndex++;\n        // End of segment is equal to destination.\n        let segmentCoeffIndex = 0;\n        while (segmentCoeffIndex < 4) {\n            matrix[equationIndex][segmentCoeffIndex + segmentIndexStart] = 1;\n            segmentCoeffIndex++;\n        }\n        equationIndex++;\n        // Smooth velocities and accelerations if there is another point left to complete\n        if (pointIndex < numPoints - 1) {\n            // Velocity Constraint\n            matrix[equationIndex][segmentIndexStart + 1] = 1;\n            matrix[equationIndex][segmentIndexStart + 2] = 2;\n            matrix[equationIndex][segmentIndexStart + 3] = 3;\n            matrix[equationIndex][segmentIndexStart + 5] = -1;\n            equationIndex++;\n\n            matrix[equationIndex][segmentIndexStart + 2] = 2;\n            matrix[equationIndex][segmentIndexStart + 3] = 6;\n            matrix[equationIndex][segmentIndexStart + 6] = -2;\n            equationIndex++;\n        }\n\n        pointIndex++;\n    }\n    return new Matrix(matrix);\n}\n\nfunction generateSolutionsMatrix(ns) {\n    let numPoints = ns.length;\n    let n = (numPoints - 1) * 4;\n    let matrix = new Array(n).fill(0).map(row => new Array(1).fill(0));\n    let pointIndex = 0, solutionIndex = 0;\n    while (solutionIndex < n) {\n        matrix[solutionIndex + 2][0] = ns[pointIndex];\n        matrix[solutionIndex + 3][0] = ns[pointIndex + 1];\n        //console.log(ns[pointIndex + 1]);\n        //console.log(matrix[solutionIndex + 3][0]);\n        solutionIndex += 4;\n        pointIndex++;\n    }\n    return new Matrix(matrix);\n}\n\nfunction getSegments(ns) {\n    let segments = [];\n    let constraints = generateConstraintMatrix(ns);\n    let solutions = generateSolutionsMatrix(ns);\n    if (constraints == null) return null;\n    let coeffs = solve(constraints, solutions);\n    //console.log(solutions)\n    let n = coeffs.rows;\n    let index = 0;\n    while (index < n) {\n        segments.push(new Segment(coeffs.get(index + 3, 0), coeffs.get(index + 2, 0), coeffs.get(index + 1, 0), coeffs.get(index, 0)));\n        index += 4;\n    }\n    return segments;\n}\n\nexport default function GetPoints(knots) {\n    let xs = [];\n    let ys = [];\n    knots.forEach((e) => {\n       xs.push(e.x);\n       ys.push(e.y);\n    });\n    let xSegments = getSegments(xs);\n    let ySegments = getSegments(ys);\n    if (xSegments == null || ySegments == null) return null;\n    let points = [];\n    let t = 0;\n    let resolution = Constants.PATH_RESOLUTION;\n    // segments = knots - 1\n    let n = knots.length - 1;\n    let index = 0;\n    while (index < n) {\n        while (t < 1) {\n            points.push(new Point(xSegments[index].compute(t), ySegments[index].compute(t)));\n            t += resolution;\n        }\n        t = 0;\n        index++;\n    }\n    return points;\n}"]},"metadata":{},"sourceType":"module"}